/** \page page-prefactors   Prefactors Used in SPHInX

The definition of prefactors and directions of the FFT is somehow arbitrary.
Make sure the methods you are going to implement are compliant to the
definitions below.

\section struct        The geometry
\subsection lattice    Lattice
The atomic geometry is generated by the basis vectors 
\f$ a_1 \f$, \f$ a_2 \f$, and \f$ a_3 \f$ (columnwise written they give matrix A). 
The reciprocal basis vectors are defined as
\f[ (b_{ij}) = B = 2 \pi |A|. \f]

\see NgStructure::aMat
\see NgStructure::bMat


\subsection  atoms     Atomic coordinates
The atomic coordinates are given in \em cartesian coordinates. If you are 
interested in \em relative coordinates (lattice units) use the mapping
\f[
   \tau^{latt} = A      \tau^{cart}
   \tau^{cart} = A^{-1} \tau^{latt}
\f]   
\par Pseudocode:
\verbatim

   NgVector3<???> tauRel = structure->aMat.inverse() ^ structure->tau(is)(ia);

\endverbatim

\see NgStructure::aMat


\subsection kpoints       k-Points
The k-point coordinates are given \em cartesian coordinates. In order to 
compute \em reciprocal \em lattice coordinates, i.e. in units of \em B
\f$ \frac{2\pi}{a_{lat}}\f$ do

\f[
   \rm{k}^{latt} = {B^T}^{-1} \rm{k}^{cart}
\f]   
Here \em B is the rowwise written matrix of the reciprocal lattice vectors
\f$ b_i \f$. For their definition see above.
\par Pseudocode:
\verbatim

   NgGkBasis gkBasis = ...;
   NgVector3<???> kVecRel = structure->bMat.transpose().inverse() ^ gkBasis.kVec(ik);

\endverbatim

\see NgStructure::bMat
\see lattice



\section dirac         Dirac notation
In what follows I use the Dirac notation
\f[ <\rm{r}|\Psi> = \Psi(\rm{r}), \qquad <\Psi|\rm{r}> = \Psi^{*}(\rm{r}) \f]
\f[ <\rm{G}|\Psi> = \Psi(\rm{G}), \qquad <\Psi|\rm{G}> = \Psi^{*}(\rm{G}) \f]



\section fft           FFT
Regardless the FFT library the program is linked against the FFT interface
provided by SPHInX is defined as follows

forward FFT:
\f[ <\rm{r}|\rm{G}> = s_{for} \, e^{+i\rm{G}\cdot \rm{r} \f]
reverse FFT:
\f[ <\rm{G}|\rm{r}> = s_{rev} \, e^{-i\rm{G}\cdot \rm{r} \f]
\par Pseudocode:
\verbatim

   NgGkBasis gBasis = ...;
   vectorG = gBasis->GtoR (vectorR);  // G --> R transformation
   vectorR = gBasis->GtoR (vectorG);  // R --> G transformation

\endverbatim

The three dimensional FFT mesh will be kept as a one dimensional vector in 
memory. Use the following transformation between both indices
\par Pseudocode:
\verbatim

   int x   = ..., y = ..., z = ...; // with  0 <= {xyz} <= mesh_{xyz}
   int idx = NgFFT::getFFTIdx (x, y, z);

\endverbatim
\see NgFFT::getFFTIdx

   
\see NgGBasis::GtoR
\see NgGBasis::RtoG
\see NgFFT::scaleFor
\see NgFFT::scaleRev


\section waves         Wavefunctions
I represent the wave functions in a plane wave basis set
\f[ <\rm{G}|Psi_{i,\rm{k}} = \sum_{\rm{G}} e^{i(\rm{G+k})\cdot \rm{r}} 
                                           c_{e,\rm{G+k}} \f]
up to a certain energy cut-off.

\f[ <\rm{r}|\Psi> = \sum_{\rm{G}} <r|G><G|\Psi> 
                  = \sum_{\rm{G}} e^{+i(\rm{G+k})\cdot \rm{r}} c_{i,\rm{G+k}} \f]

\par Pseudocode:
\verbatim

   // --- FFT from reciprocal space to realspace
   NgGkBasis gkBasis = ...;
   PsiR psiI = gkBasis(ik)->GtoR (waves(i,iSpin,ik));

\endverbatim

The wavefunctions fulfill the orthonormalization condition
\f$  <\Psi_{i,\rm{k}} | \Psi_{j,\rm{k}}> = \delta_{ij} \f$, i.e.
\f[   \sum_{\rm G} <\Psi_{i,\rm{k}}|\rm{G}><G|\Psi_{j,\rm{k}}>
   =  \delta_{ij} \f]

\f[  \sum_{\rm{r}} <\Psi_{i,\rm{k}}|\rm{r}><\rm{r}|\Psi_{j,\rm{k}}> 
   = \int_\Omega d\rm{r}\Psi_{i,\rm{k}}^{*}(\rm{r}) \Psi_{j,\rm{k}}(\rm{r})
   = \delta_{ij}
\f]
\par Pseudocode:
\verbatim

   // --- norm in |G+k> space
   NgPsiSet waves = ...;
   cout << ( waves(i,iSpin,ik) ^ waves(j,iSpin,ik) ).chop() << endl;

   // --- norm in R space
   NgGkBasis gkBasis = ...;
   PsiR psiI = gkBasis(ik)->GtoR (waves(i,iSpin,ik));  // psi_i
   PsiR psiJ = gkBasis(ik)->GtoR (waves(j,iSpin,ik));  // psi_j
   cout << (  (psiI.conj() * psiJ).sum() * structure->dOmega ) << endl;

\endverbatim

\see NgStructure::dOmega
\see NgGkBasis::operator()
\see NgGBasis::GtoR
\see NgGBasis::RtoG
\see PsiR


\section phase         Phase- and structure factors
The definition of the phase factors are
\f[ F_{i_s,i_a}(\mb{G})   = e^{-i \mb{G}   \cdot \tau_{i_s,i_a}} \f]
\f[ F_{i_s,i_a}(\mb{G+k}) = e^{-i(\mb{G+k})\cdot \tau_{i_s,i_a}} \f]
The structure factors are defined similar
\f[ S_{i_s}(\mb{G})   = \sum_{i_a} e^{-i \mb{G}   \cdot \tau_{i_s,i_a}} \f]
\f[ S_{i_s}(\mb{G+k}) = \sum_{i_a} e^{-i(\mb{G+k})\cdot \tau_{i_s,i_a}} \f]


\section rho           Charge density
The symmetrized electron charge density is given by
\f[ n(\rm{r}) = \sum_{s,\rm{k},i} \omega_{\rm{k}} f^{occ}_{i,\rm{k}} 
                       |c_{i,\rm{k}}(S_s^{-1}\rm{r})|^2 \f]
It is normalized to the number of electrons
\f[
   \int_\Omega n(\rm{r}) d \rm{r} = n_{electons}
\f]

\par Pseudocode:
\verbatim

   // --- norm in R space
   NgRho rhoR = ...;
   cout << ( rhoR(iSpin).sum() * structure->dOmega ) << endl;

   // --- norm in G space (norm is defined by G=0 component
   NgGBasis gBasis = ...;
   cout << ( gBasis->GtoR (rhoR(iSpin))(0) / NgFFT::scaleFor )        << endl;
   //     or   
   cout << ( gBasis->GtoR (rhoR(iSpin))(0) / sqrt(structure->omega) ) << endl;

\endverbatim

\ref sym   
\see NgStructure::omega
\see NgFFT::scaleFor
\see NgRho
\see NgGBasis::GtoR
\todo in NgGBasis: scaleGtoR and scaleRtoG 



\section veff         Effective potential
The effective potential will be treated analogous to the charge density,
but it is not necessary to symmetrize it. Its norm is defined by the G=0
component (NgHamiltonian::update). Please consult also paragraph about
charge denssity
\rerefho



\section sym          Symmetrization
In principle the wavefunctions have to be symmetrized like
\f[ \Psi^{sym}_{k}(\rm{r}) = \sum_{s} S_s \Psi^{not-sym}_{k}} \f]
\f[ 
    \Psi^{sym}_{k}(\rm{r}) = \sum_{\rm s} \sum_{G} 
                                S_s e^{+i(G+k)\cdot r} 
                                    c^{non-sym}_{k} 
\f]

In order to save CPU time the symmetrization has been shifted to 
the charge density according to
\f[
  n(\rm{r}) = |\Psi^{sym}_{k}(\rm{r})|^2
            = |\sum_{s} S_s  \Psi^{not-sym}_k (\rm{r})|^2
            =  \sum_{s} S_s |\Psi^{non-sym}_k (\rm{r})|^2.
\f]

The symmetry operations are 3x3 matrices in units of lattice vectors.

\note The wavefunction coefficients are \em not symmetrized!





\section pseudopot    Pseudopotentials
The pseudopotentials as imported from the fhipp pseudopotential generator
are rescaled with
\f[ 
   \Phi_{i_s,l,m} \Rightarrow 
                       \frac{\Phi_{i_s,l,m}}
                            {\sqrt{ \int dr \Phi^2_{i_s,l,m} R^2_{i_s,l}}}.
\f]. 





@author Sixten Boeck
*/
